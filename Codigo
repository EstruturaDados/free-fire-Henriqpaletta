#include <stdio.h>
#include <stdlib.h>  
#include <string.h>  
#include <time.h>   
#include <stdbool.h> 

// --- DEFINI√á√ÉO DAS ESTRUTURAS ---

// Estrutura Item: Usada tanto no vetor quanto no n√≥ da lista.
struct Item {
    char nome[30];
    char tipo[20]; 
    int quantidade;
};

// Estrutura No: Representa um elemento na Lista Encadeada.
struct No {
    struct Item dados;
    struct No *proximo;
};

// --- VARI√ÅVEIS GLOBAIS DE CONTROLE ---

// Vetor (Lista Sequencial)
#define MAX_ITENS 10
struct Item inventarioVetor[MAX_ITENS];
int contadorVetor = 0;

// Lista Encadeada (Estrutura Din√¢mica)
struct No *cabeca = NULL; // Ponteiro para o primeiro elemento da lista

// Contadores de Busca
int compSequencial = 0;
int compBinaria = 0;

// --- PROT√ìTIPOS DAS FUN√á√ïES ---

// Menu
void exibirMenuPrincipal();
void exibirMenuVetor();
void exibirMenuLista();
struct Item criarNovoItem();

// Fun√ß√µes do Vetor
void inserirItemVetor(struct Item novoItem);
void removerItemVetor(char *nomeRemover);
void listarItensVetor();
void ordenarVetor(); // Bubble Sort
void buscarSequencialVetor(char *nomeBusca);
void buscarBinariaVetor(char *nomeBusca);

// Fun√ß√µes da Lista Encadeada
void inserirItemLista(struct Item novoItem);
void removerItemLista(char *nomeRemover);
void listarItensLista();
void buscarSequencialLista(char *nomeBusca);
void liberarLista();


// ==============================================================================
// === IMPLEMENTA√á√ÉO DAS FUN√á√ïES DO VETOR (LISTA SEQUENCIAL) ===
// ==============================================================================

/**
 * @brief Adiciona um item no final do vetor.
 */
void inserirItemVetor(struct Item novoItem) {
    if (contadorVetor >= MAX_ITENS) {
        printf("\nüõë Vetor cheio. Remova um item antes de inserir.\n");
        return;
    }
    inventarioVetor[contadorVetor] = novoItem;
    contadorVetor++;
    printf("‚úÖ Item inserido no vetor. Total: %d.\n", contadorVetor);
}

/**
 * @brief Remove um item por nome e usa deslocamento (shifting) para manter a coer√™ncia.
 */
void removerItemVetor(char *nomeRemover) {
    int i, indiceEncontrado = -1;

    // Busca Sequencial (n√£o contamos aqui, pois √© parte da remo√ß√£o)
    for (i = 0; i < contadorVetor; i++) {
        if (strcmp(inventarioVetor[i].nome, nomeRemover) == 0) {
            indiceEncontrado = i;
            break;
        }
    }

    if (indiceEncontrado == -1) {
        printf("\n‚ùå Item '%s' nao encontrado no vetor.\n", nomeRemover);
        return;
    }

    // Deslocamento (Shifting)
    for (i = indiceEncontrado; i < contadorVetor - 1; i++) {
        inventarioVetor[i] = inventarioVetor[i+1];
    }
    contadorVetor--;
    printf("‚úÖ Item '%s' removido do vetor.\n", nomeRemover);
}

/**
 * @brief Lista todos os itens do vetor.
 */
void listarItensVetor() {
    if (contadorVetor == 0) {
        printf("\n‚ùå Vetor vazio.\n");
        return;
    }

    printf("\n--- ITENS NO VETOR (Total: %d) ---\n", contadorVetor);
    int i;
    for (i = 0; i < contadorVetor; i++) {
        printf("[%d] %s (Tipo: %s, Qtd: %d)\n", 
               i, inventarioVetor[i].nome, inventarioVetor[i].tipo, inventarioVetor[i].quantidade);
    }
    printf("----------------------------------\n");
}

/**
 * @brief Ordena o vetor por nome usando Bubble Sort.
 */
void ordenarVetor() {
    int i, j;
    struct Item temp;

    for (i = 0; i < contadorVetor - 1; i++) {
        for (j = 0; j < contadorVetor - 1 - i; j++) {
            // Compara os nomes. Se o item atual for "maior" que o proximo (strcmp > 0)
            if (strcmp(inventarioVetor[j].nome, inventarioVetor[j+1].nome) > 0) {
                // Troca (Swap)
                temp = inventarioVetor[j];
                inventarioVetor[j] = inventarioVetor[j+1];
                inventarioVetor[j+1] = temp;
            }
        }
    }
    printf("‚úÖ Vetor ordenado por nome (Bubble Sort).\n");
}

/**
 * @brief Realiza busca sequencial e conta compara√ß√µes.
 */
void buscarSequencialVetor(char *nomeBusca) {
    compSequencial = 0;
    int i;

    for (i = 0; i < contadorVetor; i++) {
        compSequencial++; // Conta cada compara√ß√£o
        if (strcmp(inventarioVetor[i].nome, nomeBusca) == 0) {
            printf("‚úÖ Item '%s' encontrado no indice %d.\n", nomeBusca, i);
            printf("üî¢ Compara√ß√µes realizadas (Sequencial): %d\n", compSequencial);
            return;
        }
    }
    printf("‚ùå Item '%s' nao encontrado no vetor.\n", nomeBusca);
    printf("üî¢ Compara√ß√µes realizadas (Sequencial): %d\n", compSequencial);
}

/**
 * @brief Realiza busca bin√°ria e conta compara√ß√µes (requer vetor ordenado).
 */
void buscarBinariaVetor(char *nomeBusca) {
    compBinaria = 0;
    int inicio = 0;
    int fim = contadorVetor - 1;
    int meio;
    int resultadoComp;

    while (inicio <= fim) {
        compBinaria++; // Conta cada itera√ß√£o (compara√ß√£o)
        meio = (inicio + fim) / 2;
        resultadoComp = strcmp(inventarioVetor[meio].nome, nomeBusca);

        if (resultadoComp == 0) {
            printf("‚úÖ Item '%s' encontrado no indice %d.\n", nomeBusca, meio);
            printf("üî¢ Compara√ß√µes realizadas (Bin√°ria): %d\n", compBinaria);
            return;
        } else if (resultadoComp < 0) {
            inicio = meio + 1; // Item est√° na metade superior
        } else {
            fim = meio - 1; // Item est√° na metade inferior
        }
    }

    printf("‚ùå Item '%s' nao encontrado no vetor.\n", nomeBusca);
    printf("üî¢ Compara√ß√µes realizadas (Bin√°ria): %d\n", compBinaria);
}


// ==============================================================================
// === IMPLEMENTA√á√ÉO DAS FUN√á√ïES DA LISTA ENCADEADA (ESTRUTURA DIN√ÇMICA) ===
// ==============================================================================

/**
 * @brief Insere um novo item no in√≠cio da lista.
 */
void inserirItemLista(struct Item novoItem) {
    // 1. Aloca mem√≥ria para o novo n√≥
    struct No *novoNo = (struct No *)malloc(sizeof(struct No));
    if (novoNo == NULL) {
        printf("\nüõë Erro de alocacao de memoria.\n");
        return;
    }

    // 2. Preenche os dados e aponta para a cabe√ßa atual
    novoNo->dados = novoItem;
    novoNo->proximo = cabeca;

    // 3. Atualiza a cabe√ßa para o novo n√≥
    cabeca = novoNo;
    printf("‚úÖ Item inserido no inicio da lista encadeada.\n");
}

/**
 * @brief Remove o primeiro item da lista com o nome especificado.
 */
void removerItemLista(char *nomeRemover) {
    struct No *atual = cabeca;
    struct No *anterior = NULL;

    // 1. Busca: Procura o n√≥ a ser removido
    while (atual != NULL && strcmp(atual->dados.nome, nomeRemover) != 0) {
        anterior = atual;
        atual = atual->proximo;
    }

    if (atual == NULL) {
        printf("\n‚ùå Item '%s' nao encontrado na lista.\n", nomeRemover);
        return;
    }

    // 2. Remo√ß√£o: Ajusta os ponteiros
    if (anterior == NULL) {
        // O n√≥ a ser removido √© a cabe√ßa
        cabeca = atual->proximo;
    } else {
        // O n√≥ a ser removido est√° no meio ou no final
        anterior->proximo = atual->proximo;
    }

    // 3. Libera a mem√≥ria do n√≥ removido
    free(atual);
    printf("‚úÖ Item '%s' removido da lista encadeada.\n", nomeRemover);
}

/**
 * @brief Lista todos os itens da lista encadeada, percorrendo do in√≠cio ao fim.
 */
void listarItensLista() {
    if (cabeca == NULL) {
        printf("\n‚ùå Lista encadeada vazia.\n");
        return;
    }

    printf("\n--- ITENS NA LISTA ENCADEADA ---\n");
    struct No *atual = cabeca;
    int i = 0;
    while (atual != NULL) {
        printf("[%d] %s (Tipo: %s, Qtd: %d)\n", 
               i++, atual->dados.nome, atual->dados.tipo, atual->dados.quantidade);
        atual = atual->proximo;
    }
    printf("----------------------------------\n");
}

/**
 * @brief Realiza busca sequencial na lista encadeada e conta compara√ß√µes.
 */
void buscarSequencialLista(char *nomeBusca) {
    compSequencial = 0;
    struct No *atual = cabeca;
    int i = 0;

    // Percorre a lista at√© o fim (NULL)
    while (atual != NULL) {
        compSequencial++; // Conta cada n√≥ visitado
        if (strcmp(atual->dados.nome, nomeBusca) == 0) {
            printf("‚úÖ Item '%s' encontrado na posicao %d da lista.\n", nomeBusca, i);
            printf("üî¢ Compara√ß√µes realizadas (Sequencial): %d\n", compSequencial);
            return;
        }
        atual = atual->proximo;
        i++;
    }

    printf("‚ùå Item '%s' nao encontrado na lista encadeada.\n", nomeBusca);
    printf("üî¢ Compara√ß√µes realizadas (Sequencial): %d\n", compSequencial);
}

/**
 * @brief Libera toda a mem√≥ria alocada dinamicamente para a lista.
 */
void liberarLista() {
    struct No *atual = cabeca;
    struct No *proximo;

    while (atual != NULL) {
        proximo = atual->proximo;
        free(atual); // Libera a mem√≥ria do n√≥ atual
        atual = proximo;
    }
    cabeca = NULL;
    printf("\n‚úÖ Mem√≥ria da lista encadeada liberada com sucesso.\n");
}


// ==============================================================================
// === FUN√á√ïES DE UTILIADADE E MENU ===
// ==============================================================================

/**
 * @brief Cria e retorna um novo item com dados lidos do usu√°rio.
 */
struct Item criarNovoItem() {
    struct Item novo;
    printf("\n--- DADOS DO NOVO ITEM ---\n");
    printf("Nome: ");
    scanf("%29s", novo.nome); 
    printf("Tipo (arma, cura, municao): ");
    scanf("%19s", novo.tipo);
    printf("Quantidade: ");
    scanf("%d", &novo.quantidade);
    return novo;
}

/**
 * @brief Exibe o menu principal.
 */
void exibirMenuPrincipal() {
    printf("\n============================================\n");
    printf(" ESCOLHA A ESTRUTURA (AVENTUREIRO)\n");
    printf("============================================\n");
    printf("1. Operar com Vetor (Lista Sequencial)\n");
    printf("2. Operar com Lista Encadeada (Estrutura Dinamica)\n");
    printf("0. Sair e Liberar Memoria\n");
    printf("--------------------------------------------\n");
    printf("Opcao: ");
}

/**
 * @brief Exibe o menu de opera√ß√µes do Vetor.
 */
void exibirMenuVetor() {
    printf("\n--- OPERA√á√ïES EM VETOR ---\n");
    printf("1. Inserir\n");
    printf("2. Remover\n");
    printf("3. Listar\n");
    printf("4. Ordenar (Bubble Sort)\n");
    printf("5. Buscar Sequencial\n");
    printf("6. Buscar Binaria (Requer Ordenacao!)\n");
    printf("0. Voltar ao Menu Principal\n");
    printf("Opcao: ");
}

/**
 * @brief Exibe o menu de opera√ß√µes da Lista Encadeada.
 */
void exibirMenuLista() {
    printf("\n--- OPERA√á√ïES EM LISTA ENCADEADA ---\n");
    printf("1. Inserir (no inicio)\n");
    printf("2. Remover (por nome)\n");
    printf("3. Listar\n");
    printf("4. Buscar Sequencial\n");
    printf("0. Voltar ao Menu Principal\n");
    printf("Opcao: ");
}

// ==============================================================================
// === FUN√á√ÉO PRINCIPAL (MAIN) ===
// ==============================================================================

int main() {
    int opcaoPrincipal, opcaoEstrutura;
    char nomeBusca[30];
    char nomeRemover[30];
    
    // Looping principal de escolha de estrutura
    do {
        exibirMenuPrincipal();
        if (scanf("%d", &opcaoPrincipal) != 1) {
            printf("\nOpcao invalida. Tente novamente.\n");
            while (getchar() != '\n');
            continue;
        }

        switch (opcaoPrincipal) {
            case 1: // Vetor
                do {
                    listarItensVetor();
                    exibirMenuVetor();
                    if (scanf("%d", &opcaoEstrutura) != 1) {
                        printf("\nOpcao invalida. Tente novamente.\n");
                        while (getchar() != '\n');
                        continue;
                    }

                    switch (opcaoEstrutura) {
                        case 1: inserirItemVetor(criarNovoItem()); break;
                        case 2: 
                            printf("Nome para remover: ");
                            scanf("%29s", nomeRemover); 
                            removerItemVetor(nomeRemover); 
                            break;
                        case 3: listarItensVetor(); break;
                        case 4: ordenarVetor(); break;
                        case 5: 
                            printf("Nome para Busca Sequencial: ");
                            scanf("%29s", nomeBusca); 
                            buscarSequencialVetor(nomeBusca); 
                            break;
                        case 6: 
                            printf("Nome para Busca Binaria: ");
                            scanf("%29s", nomeBusca); 
                            buscarBinariaVetor(nomeBusca); 
                            break;
                        case 0: break;
                        default: printf("\nOpcao invalida.\n"); break;
                    }
                } while (opcaoEstrutura != 0);
                break;

            case 2: // Lista Encadeada
                do {
                    listarItensLista();
                    exibirMenuLista();
                    if (scanf("%d", &opcaoEstrutura) != 1) {
                        printf("\nOpcao invalida. Tente novamente.\n");
                        while (getchar() != '\n');
                        continue;
                    }

                    switch (opcaoEstrutura) {
                        case 1: inserirItemLista(criarNovoItem()); break;
                        case 2: 
                            printf("Nome para remover: ");
                            scanf("%29s", nomeRemover); 
                            removerItemLista(nomeRemover); 
                            break;
                        case 3: listarItensLista(); break;
                        case 4: 
                            printf("Nome para Busca Sequencial: ");
                            scanf("%29s", nomeBusca); 
                            buscarSequencialLista(nomeBusca); 
                            break;
                        case 0: break;
                        default: printf("\nOpcao invalida.\n"); break;
                    }
                } while (opcaoEstrutura != 0);
                break;

            case 0:
                // Libera√ß√£o de mem√≥ria (Requisito)
                liberarLista();
                printf("\nPrograma finalizado. Sucesso na compara√ß√£o de estruturas! üëç\n");
                break;

            default:
                printf("\nOpcao invalida.\n");
        }

    } while (opcaoPrincipal != 0);

    return 0;
}
