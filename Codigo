#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h> // Para a fun√ß√£o clock() para medir tempo
#include <stdbool.h>

// --- DEFINI√á√ÉO DA ESTRUTURA ---

// Estrutura Componente: Representa uma pe√ßa necess√°ria para a torre de fuga.
struct Componente {
    char nome[30];
    char tipo[20]; // Ex: "controle", "suporte", "propulsao"
    int prioridade; // De 1 a 10
};

// --- VARI√ÅVEIS GLOBAIS DE CONTROLE ---

#define MAX_COMPONENTES 20
struct Componente componentes[MAX_COMPONENTES];
int contadorComponentes = 0;
// Vari√°vel para armazenar o n√∫mero de compara√ß√µes
long long comparacoes = 0; 
// Chave de busca para a montagem final (Requisito)
const char *CHAVE_ATIVA_TORRE = "chip central"; 

// --- PROT√ìTIPOS DAS FUN√á√ïES ---
void cadastrarComponentes();
void mostrarComponentes(struct Componente lista[], int tamanho);
void bubbleSortNome(struct Componente lista[], int tamanho);
void insertionSortTipo(struct Componente lista[], int tamanho);
void selectionSortPrioridade(struct Componente lista[], int tamanho);
void buscaBinariaPorNome(struct Componente lista[], int tamanho, const char *chave);
void medirTempo(void (*algoritmo)(struct Componente[], int), struct Componente lista[], int tamanho);


// ==============================================================================
// === IMPLEMENTA√á√ÉO DAS FUN√á√ïES DE ORDENA√á√ÉO E BUSCA ===
// ==============================================================================

/**
 * @brief Ordena os componentes por NOME usando Bubble Sort.
 * @param lista O vetor de componentes.
 * @param tamanho O n√∫mero de componentes.
 */
void bubbleSortNome(struct Componente lista[], int tamanho) {
    int i, j;
    struct Componente temp;
    comparacoes = 0;

    for (i = 0; i < tamanho - 1; i++) {
        for (j = 0; j < tamanho - 1 - i; j++) {
            comparacoes++; // Contagem da compara√ß√£o de strings
            // Se o nome atual for "maior" que o proximo, troca.
            if (strcmp(lista[j].nome, lista[j+1].nome) > 0) {
                temp = lista[j];
                lista[j] = lista[j+1];
                lista[j+1] = temp;
            }
        }
    }
    printf("\n‚úÖ Ordenacao por Nome (Bubble Sort) concluida.\n");
    printf("üî¢ Total de Comparacoes: %lld\n", comparacoes);
}

/**
 * @brief Ordena os componentes por TIPO usando Insertion Sort.
 * @param lista O vetor de componentes.
 * @param tamanho O n√∫mero de componentes.
 */
void insertionSortTipo(struct Componente lista[], int tamanho) {
    int i, j;
    struct Componente atual;
    comparacoes = 0;

    for (i = 1; i < tamanho; i++) {
        atual = lista[i];
        j = i - 1;

        // Move os elementos maiores que 'atual' para a frente
        while (j >= 0) {
            comparacoes++; // Contagem da compara√ß√£o de strings no loop
            if (strcmp(lista[j].tipo, atual.tipo) > 0) {
                lista[j + 1] = lista[j];
                j = j - 1;
            } else {
                break;
            }
        }
        lista[j + 1] = atual;
    }
    printf("\n‚úÖ Ordenacao por Tipo (Insertion Sort) concluida.\n");
    printf("üî¢ Total de Comparacoes: %lld\n", comparacoes);
}

/**
 * @brief Ordena os componentes por PRIORIDADE usando Selection Sort.
 * @param lista O vetor de componentes.
 * @param tamanho O n√∫mero de componentes.
 */
void selectionSortPrioridade(struct Componente lista[], int tamanho) {
    int i, j, min_idx;
    struct Componente temp;
    comparacoes = 0;

    for (i = 0; i < tamanho - 1; i++) {
        min_idx = i;
        for (j = i + 1; j < tamanho; j++) {
            comparacoes++; // Contagem da compara√ß√£o de inteiros
            // Encontra o componente com a menor prioridade restante
            if (lista[j].prioridade < lista[min_idx].prioridade) {
                min_idx = j;
            }
        }

        // Troca o elemento encontrado com o elemento atual
        if (min_idx != i) {
            temp = lista[min_idx];
            lista[min_idx] = lista[i];
            lista[i] = temp;
        }
    }
    printf("\n‚úÖ Ordenacao por Prioridade (Selection Sort) concluida.\n");
    printf("üî¢ Total de Comparacoes: %lld\n", comparacoes);
}

/**
 * @brief Aplica Busca Bin√°ria (Otimizada) para encontrar o componente-chave.
 * @param lista O vetor de componentes (DEVE ESTAR ORDENADO POR NOME).
 * @param tamanho O n√∫mero de componentes.
 * @param chave O nome do componente a ser buscado.
 */
void buscaBinariaPorNome(struct Componente lista[], int tamanho, const char *chave) {
    if (tamanho == 0) {
        printf("\n‚ùå Lista vazia. Nao e possivel buscar.\n");
        return;
    }
    
    // Verifica se a lista est√° em ordem (verifica√ß√£o simplificada, pois o jogador deve ordenar antes)
    if (strcmp(lista[0].nome, lista[tamanho-1].nome) > 0) {
        printf("\n‚ö†Ô∏è ERRO: O vetor nao esta ordenado por nome. Busque sequencialmente ou ordene primeiro.\n");
        return;
    }

    long long compBusca = 0;
    int inicio = 0;
    int fim = tamanho - 1;
    int meio;
    int resultadoComp;

    printf("\n--- BUSCA BINARIA DO COMPONENTE-CHAVE (%s) ---\n", chave);

    while (inicio <= fim) {
        compBusca++; 
        meio = (inicio + fim) / 2;
        resultadoComp = strcmp(lista[meio].nome, chave);

        if (resultadoComp == 0) {
            printf("\n‚úÖ COMPONENTE-CHAVE ENCONTRADO!\n");
            printf("Posicao: %d | Nome: %s | Tipo: %s | Prioridade: %d\n", 
                   meio, lista[meio].nome, lista[meio].tipo, lista[meio].prioridade);
            printf("üî¢ Total de Comparacoes na Busca: %lld\n", compBusca);
            printf("\nüöÄ TORRE DE RESGATE ATIVADA! VOCE VENCEU!\n");
            return;
        } else if (resultadoComp < 0) {
            inicio = meio + 1; // Item est√° na metade superior
        } else {
            fim = meio - 1; // Item est√° na metade inferior
        }
    }

    printf("\n‚ùå Componente-chave '%s' nao encontrado.\n", chave);
    printf("üî¢ Total de Comparacoes na Busca: %lld\n", compBusca);
}


// ==============================================================================
// === FUN√á√ïES DE UTILIDADE E MEDI√á√ÉO ===
// ==============================================================================

/**
 * @brief Cadastra os componentes da torre de fuga.
 */
void cadastrarComponentes() {
    int i;
    int num;

    printf("Quantos componentes deseja cadastrar (max %d)? ", MAX_COMPONENTES);
    if (scanf("%d", &num) != 1 || num <= 0 || num > MAX_COMPONENTES) {
        printf("Quantidade invalida. Cadastrando 3 componentes padrao.\n");
        num = 3;
    }
    // Limpa o buffer de entrada
    while (getchar() != '\n'); 

    for (i = 0; i < num; i++) {
        printf("\n--- Componente %d ---\n", i + 1);
        
        printf("Nome (max 29): ");
        fgets(componentes[i].nome, 30, stdin);
        // Remove o '\n' lido por fgets, se houver
        componentes[i].nome[strcspn(componentes[i].nome, "\n")] = 0; 
        
        printf("Tipo (controle, suporte, propulsao, etc): ");
        fgets(componentes[i].tipo, 20, stdin);
        componentes[i].tipo[strcspn(componentes[i].tipo, "\n")] = 0;
        
        do {
            printf("Prioridade (1 a 10): ");
            scanf("%d", &componentes[i].prioridade);
            while (getchar() != '\n');
        } while (componentes[i].prioridade < 1 || componentes[i].prioridade > 10);
    }
    contadorComponentes = num;
    printf("\n%d componentes cadastrados com sucesso!\n", contadorComponentes);
}

/**
 * @brief Exibe todos os componentes cadastrados.
 */
void mostrarComponentes(struct Componente lista[], int tamanho) {
    if (tamanho == 0) {
        printf("\nLista de componentes vazia.\n");
        return;
    }
    printf("\n============================================\n");
    printf(" LISTA DE COMPONENTES (%d Itens)\n", tamanho);
    printf("============================================\n");
    printf("| %-5s | %-28s | %-18s | %-10s |\n", 
           "ID", "NOME", "TIPO", "PRIORIDADE");
    printf("--------------------------------------------------------------------------\n");
    
    int i;
    for (i = 0; i < tamanho; i++) {
        printf("| %-5d | %-28s | %-18s | %-10d |\n", 
               i, lista[i].nome, lista[i].tipo, lista[i].prioridade);
    }
    printf("============================================\n");
}

/**
 * @brief Mede e exibe o tempo de execu√ß√£o de um algoritmo de ordena√ß√£o.
 * @param algoritmo Ponteiro para a fun√ß√£o de ordena√ß√£o.
 * @param lista O vetor de componentes.
 * @param tamanho O n√∫mero de componentes.
 */
void medirTempo(void (*algoritmo)(struct Componente[], int), struct Componente lista[], int tamanho) {
    clock_t inicio, fim;
    double tempo_execucao;

    inicio = clock();
    algoritmo(lista, tamanho); // Executa o algoritmo de ordena√ß√£o
    fim = clock();

    tempo_execucao = ((double)(fim - inicio)) / CLOCKS_PER_SEC;
    printf("‚è∞ Tempo de Execucao (clock()): %f segundos\n", tempo_execucao);
}


// ==============================================================================
// === FUN√á√ÉO PRINCIPAL (MAIN) ===
// ==============================================================================

int main() {
    int opcao;

    printf("--- MODULO AVAN√áADO DE COMPONENTES (MESTRE) ---\n");
    cadastrarComponentes();
    
    do {
        mostrarComponentes(componentes, contadorComponentes);
        
        printf("\n============================================\n");
        printf(" ESCOLHA A ESTRATEGIA DE ORGANIZACAO\n");
        printf("============================================\n");
        printf("1. Ordenar por NOME (Bubble Sort)\n");
        printf("2. Ordenar por TIPO (Insertion Sort)\n");
        printf("3. Ordenar por PRIORIDADE (Selection Sort)\n");
        printf("4. BUSCA BINARIA (Ativar Torre)\n");
        printf("0. Sair e Finalizar Missao\n");
        printf("--------------------------------------------\n");
        printf("Opcao: ");
        
        if (scanf("%d", &opcao) != 1) {
            printf("\nOpcao invalida. Tente novamente.\n");
            while (getchar() != '\n');
            opcao = -1; // Valor invalido para continuar o loop
            continue;
        }
        while (getchar() != '\n'); // Limpa o buffer ap√≥s scanf

        // Cria uma c√≥pia tempor√°ria do vetor para garantir que a ordena√ß√£o n√£o afete as op√ß√µes subsequentes
        struct Componente tempComponentes[MAX_COMPONENTES];
        memcpy(tempComponentes, componentes, contadorComponentes * sizeof(struct Componente));
        
        switch (opcao) {
            case 1:
                printf("\n--- ESTRATEGIA: ORGANIZAR POR NOME ---\n");
                medirTempo(bubbleSortNome, tempComponentes, contadorComponentes);
                // Copia o resultado da ordena√ß√£o de volta para o vetor principal (necess√°rio para a Busca Bin√°ria)
                memcpy(componentes, tempComponentes, contadorComponentes * sizeof(struct Componente));
                break;
            case 2:
                printf("\n--- ESTRATEGIA: ORGANIZAR POR TIPO ---\n");
                medirTempo(insertionSortTipo, tempComponentes, contadorComponentes);
                // Nao copia de volta para o principal, pois a Busca Bin√°ria so funciona com ordenacao por nome.
                break;
            case 3:
                printf("\n--- ESTRATEGIA: ORGANIZAR POR PRIORIDADE ---\n");
                medirTempo(selectionSortPrioridade, tempComponentes, contadorComponentes);
                // Nao copia de volta.
                break;
            case 4:
                // Requisito: A busca bin√°ria deve ser aplicada ap√≥s a ordena√ß√£o por nome
                printf("\n--- TENTATIVA DE ATIVACAO DA TORRE ---\n");
                buscaBinariaPorNome(componentes, contadorComponentes, CHAVE_ATIVA_TORRE);
                break;
            case 0:
                printf("\nMissao Finalizada. Componentes desconectados.\n");
                break;
            default:
                printf("\nOpcao invalida. Escolha uma estrategia valida.\n");
        }

    } while (opcao != 0);

    return 0;
}
